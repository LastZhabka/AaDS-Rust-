# Algorithms and Data structures (Rust).

In the past I tried to implement all the algorithms I know in one project on GitHub. But I was too lazy to complete this idea.

Now I'm learning the Rust programming language, and I want to improve my implementation skills on Rust. So I decided to combine practice and implementation of my past idea. Every day I will spent some time to implement algorithms and data structures on Rust language.

<details>
<summary>TO-DO list:</summary> 
  
<details>
<summary>Data structures :</summary> 
  
- [x] :white_check_mark: **Stack**
- [x] :white_check_mark: **Queue**
- [x] :white_check_mark: **Prefix sums**
- [x] :white_check_mark: **Segment tree static**
- [x] :white_check_mark: **Segment tree with point updates**
- [ ] :x: Bitset (Simple)
- [ ] :x: DSU
- [ ] :x: SQRT decomposition
- [ ] :x: Segment tree with range updates
- [ ] :x: Sparse table
- [ ] :x: Fenwick tree
- [ ] :x: Prefix tree
- [ ] :x: Disjoint sparse table
- [ ] :x: Binominal heap
- [ ] :x: Euler tour tree
- [ ] :x: Cartesian tree
- [ ] :x: Sufix array
- [ ] :x: Palindromic tree
- [ ] :x: Semi-Persistent DSU
- [ ] :x: Laddaer decomposition
- [ ] :x: Centroid decomoposition
- [ ] :x: Aho-Corasick automat
- [ ] :x: Persistent segment tree
- [ ] :x: Compressed prefix tree
- [ ] :x: Fibonacci heap
- [ ] :x: SQRT tree
- [ ] :x: Segment tree beats
- [ ] :x: Heavy-Light Decomposition
- [ ] :x: Li-Chao tree
- [ ] :x: Splay tree
- [ ] :x: Link-Cut tree
- [ ] :x: Two-dimensional segment tree
- [ ] :x: Dominator tree
- [ ] :x: Persisten cartesian tree
- [ ] :x: Red-Black tree
- [ ] :x: Block-Cut tree
</details>
<details>
<summary>Math algorithms:</summary> 

- [ ] :x: Fast Fourie Transform
- [x] :white_check_mark: **Euclidean algorithm**
- [ ] :x: Extended euclidean algorithm
- [ ] :x: Sprague-Grundy
- [ ] :x: Pascal's triangle
- [ ] :x: Modulo operations
- [ ] :x: Binary GCD algorithm
- [ ] :x: Operations with matrices
- [ ] :x: Binary operations
- [ ] :x: Number Theoretic Transform
- [ ] :x: Simple Diophantine equations
- [ ] :x: XOR - basis
- [ ] :x: Gaussâ€“Jordan elimination
- [ ] :x: Binominal coefficents
- [ ] :x: Euler function
- [ ] :x: Primality test (SQRT)
- [ ] :x: Principle of Inclusion and Exclusion
- [ ] :x: Gray's code
- [ ] :x: Eratosphenes sieve
- [ ] :x: Chinese Reminder theorem 
- [x] :white_check_mark: **Binary Exponentiation**
- [ ] :x: Lagrange's interpolation polynomial
- [ ] :x: Factorization
- [ ] :x: Binary multiplication
- [ ] :x: Uncertainty calculation
</details>
<details>
<summary>Graph algorithms:</summary> 

- [x] :white_check_mark: **DFS**
- [x] :white_check_mark: **BFS**
- [ ] :x: Dijkstra algorithm
- [ ] :x: Floyd-Warshall algorithm
- [ ] :x: Ford-Belman algorithm
- [ ] :x: Ford-Belman algorithm for finding negative cycles
- [ ] :x: A* algorithm
- [ ] :x: 0-1 BFS
- [ ] :x: 0-k BFS
- [ ] :x: Multisource BFS
- [ ] :x: Multisource Dijkstra
- [ ] :x: Topological sort
- [ ] :x: Condensation of the graph
- [ ] :x: Finding of all bridges
- [ ] :x: Articulation points
- [ ] :x: Kuhn's algorithm
- [ ] :x: SPFA 
- [ ] :x: Prim's algorithm
- [ ] :x: Boruvki algorithm
- [ ] :x: Kruskal algorithm
- [ ] :x: DFS tree
- [ ] :x: Euler path and cycle
- [ ] :x: Finding cycle in graph
- [ ] :x: Binary lifting
- [ ] :x: LCA
- [ ] :x: LCA to RMQ
- [ ] :x: Farakh Colton-Bender algorithm
- [ ] :x: LA
- [ ] :x: Tarjan's algorithm.
</details>
<details>
<summary>Dynamic Programming algorithms:</summary> 
  
- [ ] :x: Knapsack problem
- [ ] :x: Largest Common Subsequence
- [ ] :x: Largest Increasing Subsequence
- [ ] :x: DP via matrices
- [ ] :x: Divide and conquer DP optimization
- [ ] :x: Bitmask DP
- [ ] :x: Digit DP
- [ ] :x: Subtrees DP
- [ ] :x: Knuth-optimization
- [ ] :x: Alien trick
- [ ] :x: DP on Profile
- [ ] :x: DP on Broken Profile
- [ ] :x: SOS DP
- [ ] :x: DP on subsegments
- [ ] :x: Convex hull trick
- [ ] :x: Slope trick
- [ ] :x: DP segment tree optimization
- [ ] :x: DP prefix sum optimization
</details>
<details>
<summary>Other:</summary> 
  
- [ ] :x: Divide and Conquer
- [ ] :x: Binary search
- [ ] :x: Ternary search
- [ ] :x: Meet in the middle
- [ ] :x: SQRT-trick
- [ ] :x: Linear search
- [ ] :x: Mo's algorithm
- [ ] :x: DP recovery methods
- [ ] :x: Two pointers
- [ ] :x: Sliding window
- [ ] :x: Sweepline
- [ ] :x: Sweepline Mo
- [ ] :x: Small to Large
- [ ] :x: Static structure to Dynamic structure trick
- [ ] :x: Queue-like Undoing
- [ ] :x: Retro-analysis
- [ ] :x: Mo's algorithm on tree
- [ ] :x: Plane Rotation
- [ ] :x: Dirichlet's principle
</details>
</details>
