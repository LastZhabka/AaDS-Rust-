# Algorithms and Data structures (Rust).

In the past I tried to implement all the algorithms I know in one project on GitHub. But I was too lazy to complete this idea.

Now I'm learning the Rust programming language, and I want to improve my implementation skills on Rust. So I decided to combine practice and implementation of my past idea. Every day I will spent some time to implement algorithms and data structures on Rust language.

<details>
<summary>TO-DO list:</summary> 
  
<details>
<summary>Data structures :</summary> 
  
- [x] **Stack**
- [x] **Queue**
- [ ] Prefix sums
- [x] **Segment tree static**
- [x] **Segment tree with point updates**
- [ ] Bitset (Simple)
- [ ] DSU
- [ ] SQRT decomposition
- [ ] Segment tree with range updates
- [ ] Sparse table
- [ ] Fenwick tree
- [ ] Prefix tree
- [ ] Disjoint sparse table
- [ ] Binominal heap
- [ ] Euler tour tree
- [ ] Cartesian tree
- [ ] Sufix array
- [ ] Palindromic tree
- [ ] Semi-Persistent DSU
- [ ] Laddaer decomposition
- [ ] Centroid decomoposition
- [ ] Aho-Corasick automat
- [ ] Persistent segment tree
- [ ] Compressed prefix tree
- [ ] Fibonacci heap
- [ ] SQRT tree
- [ ] Segment tree beats
- [ ] Heavy-Light Decomposition
- [ ] Li-Chao tree
- [ ] Splay tree
- [ ] Link-Cut tree
- [ ] Two-dimensional segment tree
- [ ] Dominator tree
- [ ] Persisten cartesian tree
- [ ] Red-Black tree
- [ ] Block-Cut tree
</details>
<details>
<summary>Math algorithms:</summary> 

- [ ] Fast Fourie Transform
- [ ] Euclidean algorithm
- [ ] Extended euclidean algorithm
- [ ] Sprague-Grundy
- [ ] Pascal's triangle
- [ ] Modulo operations
- [ ] Binary GCD algorithm
- [ ] Operations with matrices
- [ ] Binary operations
- [ ] Number Theoretic Transform
- [ ] Simple Diophantine equations
- [ ] XOR - basis
- [ ] Gaussâ€“Jordan elimination
- [ ] Binominal coefficents
- [ ] Euler function
- [ ] Primality test (SQRT)
- [ ] Principle of Inclusion and Exclusion
- [ ] Gray's code
- [ ] Eratosphenes sieve
- [ ] Chinese Reminder theorem 
- [ ] Binary Exponentiation 
- [ ] Lagrange's interpolation polynomial
- [ ] Factorization
- [ ] Binary multiplication
- [ ] Uncertainty calculation
</details>
<details>
<summary>Graph algorithms:</summary> 

- [ ] DFS
- [ ] BFS
- [ ] Dijkstra algorithm
- [ ] Floyd-Warshall algorithm
- [ ] Ford-Belman algorithm
- [ ] Ford-Belman algorithm for finding negative cycles
- [ ] A* algorithm
- [ ] 0-1 BFS
- [ ] 0-k BFS
- [ ] Multisource BFS
- [ ] Multisource Dijkstra
- [ ] Topological sort
- [ ] Condensation of the graph
- [ ] Finding of all bridges
- [ ] Articulation points
- [ ] Kuhn's algorithm
- [ ] SPFA 
- [ ] Prim's algorithm
- [ ] Boruvki algorithm
- [ ] Kruskal algorithm
- [ ] DFS tree
- [ ] Euler path and cycle
- [ ] Finding cycle in graph
- [ ] Binary lifting
- [ ] LCA
- [ ] LCA to RMQ
- [ ] Farakh Colton-Bender algorithm
- [ ] LA
- [ ] Tarjan's algorithm.
</details>
<details>
<summary>Dynamic Programming algorithms:</summary> 
  
- [ ] Knapsack problem
- [ ] Largest Common Subsequence
- [ ] Largest Increasing Subsequence
- [ ] DP via matrices
- [ ] Divide and conquer DP optimization
- [ ] Bitmask DP
- [ ] Digit DP
- [ ] Subtrees DP
- [ ] Knuth-optimization
- [ ] Alien trick
- [ ] DP on Profile
- [ ] DP on Broken Profile
- [ ] SOS DP
- [ ] DP on subsegments
- [ ] Convex hull trick
- [ ] Slope trick
- [ ] DP segment tree optimization
- [ ] DP prefix sum optimization
</details>
<details>
<summary>Other:</summary> 
  
- [ ] Divide and Conquer
- [ ] Binary search
- [ ] Ternary search
- [ ] Meet in the middle
- [ ] SQRT-trick
- [ ] Linear search
- [ ] Mo's algorithm
- [ ] DP recovery methods
- [ ] Two pointers
- [ ] Sliding window
- [ ] Sweepline
- [ ] Sweepline Mo
- [ ] Small to Large
- [ ] Static structure to Dynamic structure trick
- [ ] Queue-like Undoing
- [ ] Retro-analysis
- [ ] Mo's algorithm on tree
- [ ] Plane Rotation
- [ ] Dirichlet's principle
</details>
</details>
